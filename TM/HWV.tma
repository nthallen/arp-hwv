#=====================================================================
# Pre-SEAC4RS Calibrations March, April, May 2012
# Runs HHH -> LyA Calibration System
#=====================================================================


#---------------------------------------------------------------------
# Partition 1: Main Line Code
#---------------------------------------------------------------------

### Need to verify switches before we use them
### Both switches UP for flight.
### I think the information below is incorrect! [03/19/12 JBS]
# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised) Most algo processing suspended.
# If both switches are On (1, raised) Shutdown begins immediately.

# { tma_hold( ( (IOSwS & 3) == 1) || ( (IOSwS & 3) == 2) ); }
# { depending on (Shutdown) {} 
#   else {
#      if ( (IOSwS & 3) == 3)
#          Validate Shutdown;
#   }
# }

%{
  #include "msg.h"
  int H2O2_Lamp_Enable = 1;
%}

# INITIALIZE
State Init {
       > Telemetry Start
  +1   > Fail Light Off
  +5   > Set Axis A Heat Set Pt 0
  +5   > Set lab Flow bubbler Set Pt 0
  +5   > Set lab Flow air Set Pt 3
  +5   Validate Standby;
}

# WAIT 
State Standby {
        depending on (OFF_GROUND) { Validate Record; }
        depending on (AI_Fail)   { Validate Shutdown; }
}

# RECORD  
State Record {
        depending on (ON_GROUND) { Validate Shutdown; }
        depending on (h2o2failA) { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
        "In Record";
  +1200  > Set lab Flow bubbler Set Pt 0
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 0.5
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 1 
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 1.5
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 2
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 3
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 3
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 2
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 1.5
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 1
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 0.5
  +5    > Set lab Flow air Set Pt 4
  +300  > Set lab Flow bubbler Set Pt 0
  +5    > Set lab Flow air Set Pt 4
#
  +300  > Set lab Flow bubbler Set Pt 0
  +5    Validate Shutdown; 
}

# SHUTDOWN
State Shutdown {
  +1  > Soldrv A select mode 0
      Hold until valid (h2o2shutOffA,h2o2heatOffA,DFB_Shutdown) or 55;
 +10  > Fail Light On
      > quit
}


#---------------------------------------------------------------------# Partition 3: Altitude
#---------------------------------------------------------------------

Partition

# This partition converts pressure (altitude) into states 
# (ON_GROUND, OFF_GROUND, IN_AIR). \
# The threshold pressures each have two values - one for 
# the flight up and the other for the flight down.
# This provides hysteresis and prevents bouncing.  
# We are effectively using two switches: 
# 	ON_GROUND and IN_AIR (BELOW CLOUDS = ABOVE CLOUDS)
# REF: 650 torr ~5000 ft

%{ /* Altitude definitions */
    double P_ground_up = 525.;
    double P_ground_dn = 575.;
    double P_clouds_up = 280.;
    double P_clouds_dn = 370.;
    int using_swp = 0;
%}

State ON_GROUND {
  { using_swp = 0; }
  { if (using_swp || (DACS_P > 0 && DACS_P < P_ground_up))
      Validate OFF_GROUND;
  }
}

State OFF_GROUND {
  { if ((using_swp == 2) || (!using_swp && DACS_P > 0 && DACS_P < P_clouds_up)) {
      Validate IN_AIR;
    } else if ((using_swp == 4) || (!using_swp && DACS_P > P_ground_dn)) {
      Validate ON_GROUND;
    }
  }
}

State IN_AIR {
  { if ( (using_swp == 3) || (!using_swp && DACS_P > P_clouds_dn))
      Validate OFF_GROUND;
  }
}


#---------------------------------------------------------------------# Partition 5: Axis A Lamp On/Off
#---------------------------------------------------------------------

Partition

%{
  int h2o2AnreSets = 0;
%}

# INITIALIZE HEATER & LAMP
State h2o2initA {
  +4  > Set Axis A Heat Set Pt 0
  +1  > Command Lamp Module A off
      depending on (OFF_GROUND) { Validate h2o2turnOnA; }
      depending on (IN_AIR) { Validate h2o2turnOnA; }
}

# TURNS ON LAMP
State h2o2turnOnA {
       depending on (1 Hz) {
         if ( !H2O2_Lamp_Enable ) Validate h2o2shutOffA;
       }
       depending on (Shutdown) { Validate h2o2shutOffA; }
  +2   > Set Axis A RF Set Pt 6.5
  +2   > Command Lamp Module A on
  +10  Validate h2o2recordA;     
}

# WATCHDOG FOR LAMP GOING OFF
State h2o2recordA {
        depending on (Shutdown) { Validate h2o2shutOffA; }
        depending on (1 Hz) {
          if ( !H2O2_Lamp_Enable ) Validate h2o2shutOffA;
        }
        Hold until (convert(A_IRV) < 0.2);
        Hold until (convert(A_IRV) > 0.2) or 5 else {
          msg(2,"**Lamp turned off!!**");  
          Validate h2o2reSetA; } 
        Validate h2o2recordA;
}

State h2o2reSetA {
        depending on (Shutdown) { Validate h2o2shutOffA; }
        > Command Lamp Module A off
  +1    > Set Axis A RF Set Pt 0
        { if ( ++h2o2AnreSets >= 10 ) {
            msg(2,"Lamp A Max ReSet Count Reached");
            Validate h2o2failA;
          }
        }
  +4    Validate h2o2turnOnA;
}

State h2o2shutOffA {
  +1    > Command Lamp Module A off
  +1    > Set Axis A RF Set Pt 0
}

State h2o2failA {}


#---------------------------------------------------------------------# Partition 6: Axis A Lamp Heater On/Off
#---------------------------------------------------------------------

Partition

State h2o2heatinitA {
        depending on (h2o2recordA) { Validate h2o2heatOnA; }
}

# TURN ON LAMP HEATER & START SOL CYCLE
# WATCHDOG FOR LAMP RUNNING DEEP
State h2o2heatOnA {
        depending on (Shutdown) { Validate h2o2heatOffA; }
        depending on (h2o2shutOffA) { Validate h2o2heatOffA; }
        depending on (h2o2reSetA) { Validate h2o2heatOffA; }
  +1    > Set Axis A RF Set Pt 6.5
  +8    > Set Axis A Heat Set Pt 2.4
  +1    > Soldrv A select mode 3
        Hold until (convert(A_IRV) > 4.0);
        { msg(2,"**Too much heat on A - running deep!**"); }
        > Set Axis A Heat Set Pt 0
        Hold until (convert(A_IRV) < 1.0);
        > Set Axis A Heat Set Pt 2.4
        Validate h2o2heatOnA;       
}

State h2o2heatOffA {
        depending on (h2o2recordA) { Validate h2o2heatOnA; }
        > Set Axis A Heat Set Pt 0
}


#----------------------------------------------------------------
# Partition 7: HHH
#----------------------------------------------------------------

Partition

State HHH_Init {
     Depending on (Shutdown) { Validate HHH_Shutdown; }
     Depending on (DFB_Shutdown) { Validate HHH_Shutdown; }
     Depending on (IN_AIR) { Validate HHH_Startup; }
     Depending on (OFF_GROUND) { Validate HHH_Startup; }
}

State HHH_Startup {
     Depending on (Shutdown) { Validate HHH_Shutdown; }
     Depending on (DFB_Shutdown) { Validate HHH_Shutdown; }
     Depending on (ON_GROUND) { Validate HHH_Shutdown; }
     Validate DFB_HHH;
}

State HHH_Shutdown {}

#----------------------------------------------------------------
# Partition 8: Laser1 HHH 1.4um DFB
#----------------------------------------------------------------

Partition

%{
 int num_DFB_recovers=0;
 #define LOW_CURRENT 0.02
 #define DFB_TEMP_LIMIT 3.0
 #define DFB_TEMP_OK(x) (x < DFB_TEMP_LIMIT)
%}
# DFB1 Starting and Stopping

State DFB_Init {
  +1 > SSP Stop
  +1 > QCLI Stop
     Validate DFB_Idle;
}

State DFB_Idle {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
}

State DFB_Start {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    Hold until ( SSP_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP Not Ready in DFB_Start" );
      Validate DFB_SSP_Recover;
    }
    Hold until ( DFB_TEMP_OK(convert(LTE1R4T)) );
    Hold until ( ((QCLI_s & 0x3938)^0x1000) == 0 ) or 5
    else Validate DFB_QCLI_Recover;
 +1 > SSP Start
    Hold until ( SSP_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in DFB_Start" );
      Validate DFB_SSP_Recover;
    }
    > QCLI Run
    Hold until ( SSP_Status == SSP_STATUS_TRIG ) or 20
    else Validate DFB_SSP_Recover;
    { num_DFB_recovers = 0; }
 +1 Validate DFB_Watch;
}

State DFB_Watch NoLog {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    { if ( SSP_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP Went Ready Spontaneously" );
        Validate DFB_SSP_Recover;
      }
    }
         # convert(HDFB_I) < LOW_CURRENT ||
    hold until ( SSP_Status != SSP_STATUS_TRIG ||
         !DFB_TEMP_OK(convert(LTE1R4T)) );
    # hold until ( DFB_TEMP_OK(convert(LTE1R4T)) && 
    #     convert(HDFB_I) >= LOW_CURRENT) or 1
    hold until ( DFB_TEMP_OK(convert(LTE1R4T)) ) or 2
    else Validate DFB_Out_Spec;
    hold until ( SSP_Status == SSP_STATUS_TRIG ) or 5
    else Validate DFB_SSP_Recover;
    Validate DFB_Watch;
}

State DFB_SSP_Recover NoLog {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP Stop
    { if ( ++num_DFB_recovers > 20 ) {
        nl_error( 2, "Exceeded num_DFB_recovers. Trying reSet" );
        num_DFB_recovers = 0;
        Validate DFB_QCLI_ReSet;
      }
    }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate DFB_SSP_Not_Talking;
 +2 > QCLI Stop
    Validate DFB_Start;
}

State DFB_SSP_Not_Talking {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP Stop
    { if ( ++num_DFB_recovers > 20 ) Validate DFB_Fail; }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate DFB_SSP_Not_Talking;
    Validate DFB_SSP_Recover;
}

State DFB_Fail {
    > Log Laser System 1 Has Failed
 +1 Validate DFB_Shutdown;
}

State DFB_Shutdown {
    > SSP Stop
 +1 > QCLI Stop
    > Log Laser System 1 Has Shutdown
}

State DFB_Out_Spec {
   > QCLI Stop
 +1 Validate DFB_QCLI_Recover;
}

State DFB_QCLI_Recover {
   Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }

 +1  { nl_error( 2, "QCLI reporting error status 0x%04X", QCLI_s ); }
 +1  > QCLI Clear Errors
     Hold until ( ((QCLI_s & 0x3938) ^0x1000) == 0 ) or 5
     else {
       nl_error( 2, "QCLI error did not clear: ReSetting" );
       Validate DFB_QCLI_ReSet;
     }
     Validate DFB_Start;
}

State DFB_QCLI_ReSet {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    { if ( ++num_DFB_recovers > 20 ) {
        nl_error( 2,"Exceeded num_DFB_recovers in QCLI_ReSet: Invoking shutdown" );
        Validate DFB_Fail;
      }
    }
 +1 > Command QCLI ReSet On
    > Command QCLI ReSet Off
    Hold until ( ((QCLI_s & 0x3938) ^ 0x1000) == 0 ) or 2
    else > QCLI clear errors
    Hold until ( ((QCLI_s & 0x3938) ^ 0x1000) == 0 ) or 2
    else Validate DFB_QCLI_ReSet;
    { ci_sendfcmd( 0, "Select QCLI Waveform Number %d\n", QCLI_Wave );
      Validate DFB_Start;
    }
}

State DFB_Stop {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP Stop
 +1 > QCLI Stop
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in DFB_Stop" ); }
    Validate DFB_Idle;
}

#Running Waveforms

State DFB_HHH {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP Stop
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in DFB_HHH" ); }
    > QCLI Stop
 +2 > Select QCLI Waveform HHH
 +2 Validate DFB_Start;
}


#---------------------------------------------------------------------# Partition 9: Realtime File Input
#---------------------------------------------------------------------

Partition

State ReadFile_idle {}

State ReadFile "HWV.tmas" {
  +5 Validate ReadFile_idle;
}


#---------------------------------------------------------------
# Partition 10: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------

Partition

State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SWStat == SWS_TIME_WARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}


#---------------------------------------------------------------
# Partition 11: Analog Input Monitoring
#---------------------------------------------------------------

Partition

%{
  AI_T30K Last_HPV1T = 0;
  static int HPV1T_static_count = 0;
  static int HPV1T_delta_count = 0;
  static int AI_ReSet_count = 0;
%}
State AI_Watch {
    { if ( HPV1T == Last_HPV1T ) {
	if ( ++HPV1T_static_count >= 15 ) {
	  msg(2, "HPV1T has not changed in 15 seconds");
	  HPV1T_delta_count = 0;
	  Validate AI_ReSet;
	}
      } else {
	Last_HPV1T = HPV1T;
	HPV1T_static_count = 0;
	if ( ++HPV1T_delta_count > 5 ) {
	  HPV1T_delta_count = 0;
	  AI_ReSet_count = 0;
	}
      }
    }
}

State AI_ReSet {
      > AI ReSet
  +1  > AI Double Convert Row Zero
      { if ( ++AI_ReSet_count >= 10 ) {
	  msg(2,"AI Max ReSet Count Reached");
	  Validate AI_Fail;
	}
      }
      Hold until ( HPV1T != Last_HPV1T ) OR 15
      else Validate AI_ReSet;
      Validate AI_Watch;
}

State AI_Fail {}

