# =============================================================================
# WB57 flights, March, April 2011; Houston, TX, MACPEX mission.
# Flight two.tma.  Runs dual axis water vapor (2").
# =============================================================================


# -----------------------------------------------------------------------------
# Partition 1: Main Line Code
# -----------------------------------------------------------------------------

# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised), most algo processing is suspended.
# If both switches are On (1, raised) Shutdown begins immediately.

{ tma_hold( ( (IOSwS & 3) == 1) || ( (IOSwS & 3) == 2) ); }
{ depending on (Shutdown) {} 
   else {
      if ( (IOSwS & 3) == 3)
          Validate Shutdown;
   }
}

%{
  int Scan_Mode_Always = 1;
  int H2O2_Lamp_Enable = 1;
%}

# INITIALIZE
State Init {
        > Telemetry Start
+1      > Fail lamp 0 off
+1      > Soldrv A select mode 2
+5      > Soldrv A select mode 0
+4      Validate Standby;
}

# WAIT 
State Standby {
        depending on (BELOW_CLOUDS) { Validate Record; }
        depending on (ABOVE_CLOUDS) { Validate Record; }
}

# RECORD  
State Record {
        depending on (ON_GROUND) { Validate Shutdown; }
        "In Record";
}

# SHUTDOWN
State Shutdown {
+1      > Soldrv A select mode 0
+55     > Fail Light on					%%Fail lamp 0 on
+1      > quit
}


# -----------------------------------------------------------------------------
# Partition 2: Realtime File Input
# -----------------------------------------------------------------------------

Partition

State ReadFile_idle {}

State ReadFile "two.tmas" {
  +5 Validate ReadFile_idle;
}

# -----------------------------------------------------------------------------
# Partition 3: Software Status
# -----------------------------------------------------------------------------

Partition

#     _____________________________________  Above Clouds
#        ^                |
#   swp= | 2 = high       v 3 = low
#     _____________________________________  Below Clouds
#        ^                |
#        | 1 = takeoff    v 4 = landing
#     _____________________________________  Ground   
#

State SW_Stat_Wait {
  { int reset_it;
    reset_it = 1;
    switch (SWStat) {
        default:
        case 0:   reset_it = 0; break;
        case 1:   depending on (ON_GROUND) using_swp = 1; break;
        case 2:
        case 4:   depending on (BELOW_CLOUDS) using_swp = SWStat; break;
        case 3:   depending on (ABOVE_CLOUDS) using_swp = SWStat; break; 
        case 14:  Scan_Mode_Always = 1; break;
        case 15:  Scan_Mode_Always = 0; break;
        case 22:  break;
        case 25:  H2O2_Lamp_Enable = 1;
                  depending on (h2o2shutOffC) Validate h2o2initC; 				%% Change to A?
				  depending on (h2o2shutOffB) Validate h2o2initB; break;	%% Change to A?
        case 26:  H2O2_Lamp_Enable = 0; break;
        case 200:
        case 254: Validate ReadFile; break;
        case 255: Validate Shutdown; break;
    }
    if (reset_it) Validate SW_Stat_Reset;
  }
}

State SW_Stat_Reset {
  > SWStatus Set To 0
  Hold until (SWStat == 0) or 10;
  Validate SW_Stat_Wait;
}


# -----------------------------------------------------------------------------
# Partition 4: Altitude
# -----------------------------------------------------------------------------

Partition

# This partition converts pressure (altitude) into states 
# (ON_GROUND, BELOW_CLOUDS, ABOVE_CLOUDS). \
# The threshold pressures each have two values - one for 
# the flight up and the other for the flight down.
# This provides hysteresis and prevents bouncing.  
# We are effectively using two switches: 
# 	ON_GROUND and IN_AIR (BELOW CLOUDS = ABOVE CLOUDS)
# REF: 650 torr ~5000 ft

%{ /* Altitude definitions */
        double P_ground_up = 525.;
        double P_ground_dn = 575.;
        double P_clouds_up = 280.;
        double P_clouds_dn = 370.;
        int using_swp = 0;
%}

State ON_GROUND {
        { using_swp = 0; }
        { if (using_swp || (convert(TD_HP) < P_ground_up))
                Validate BELOW_CLOUDS;
        }
}

State BELOW_CLOUDS {
        { if ((using_swp == 2) || (!using_swp && convert(TD_HP) < P_clouds_up)) {
                Validate ABOVE_CLOUDS;
          } else if ((using_swp == 4) || (!using_swp && convert(TD_HP) > P_ground_dn)) {
                Validate ON_GROUND;
          }
        }
}

State ABOVE_CLOUDS {
        { if ( (using_swp == 3) || (!using_swp && convert(TD_HP) > P_clouds_dn))
                Validate BELOW_CLOUDS;
        }
}


# -----------------------------------------------------------------------------
# Partition 5: Throttle Valve Control
# -----------------------------------------------------------------------------

Partition

State Throttle_Standby {
        depending on (BELOW_CLOUDS) { Validate Throttle_init; }
        depending on (ABOVE_CLOUDS) { Validate Throttle_init; }
}

# INITIALIZE
State Throttle_init     {
        > drive Throttle Valve __		%drive secondary throttle valve in 48000
+2      > drive Throttle Valve __		%drive secondary throttle valve out 10000
+5      > drive Throttle Valve __		%drive secondary throttle valve to 15000
+5      Validate Throttle_scan;
}

# RUN & SCAN
State Throttle_scan {
        depending on (ON_GROUND) { Validate Throttle_shut; }
        depending on (Shutdown) { Validate Throttle_shut; }
        > drive Throttle Valve __		%drive secondary throttle valve to 47000
        Hold until (SWStat == 22) or 34:00;
        > drive Throttle Valve __		%drive secondary throttle valve to 40000
+2:00   > drive Throttle Valve __		%drive secondary throttle valve to 35000
+2:00   > drive Throttle Valve __		%drive secondary throttle valve to 30000
+2:00   Validate Throttle_scan;
}

State Throttle_shut {
        > drive Throttle Valve __		%drive secondary throttle valve in 48000
}


# -----------------------------------------------------------------------------
# Partition 6: Axis A Lamp On/Off
# -----------------------------------------------------------------------------

Partition

# WAIT UNTIL WB-57 TAKES OFF
# INITIALIZE HEATER & LAMP
State h2o2initA {
+4      > Set Axis A Heat Set Pt 0
+1      > Command Lamp Module A on
        depending on (BELOW_CLOUDS) { Validate h2o2turnOnA; }
        depending on (ABOVE_CLOUDS) { Validate h2o2turnOnA; }
}

# TURNS ON LAMP
State h2o2turnOnA {
        depending on (1 Hz) {
           if ( !H2O2_Lamp_Enable ) Validate h2o2shutOffA;
        }
        depending on (Shutdown) { Validate h2o2shutOffA; }
+2      > Set Axis A RF Set Pt 5
+2      > Command Lamp Module A on
+10     Validate h2o2recordA;     
}

# For test purposes, state h2o2record was set for only a few minutes.  For
# flight, set to at least one hour, depending on flight plan/duration.
# WATCHDOG FOR LAMP GOING OFF
State h2o2recordA {
        depending on (Shutdown) { Validate h2o2shutOffA; }
        depending on (1 Hz) {
                if ( !H2O2_Lamp_Enable ) Validate h2o2shutOffA;
        }
        Hold until (convert(BVisV) < 0.2);			%% AVisV < ??
        Hold until (convert(BVisV) > 0.2) or 5 else {		%% AVisV > ??
           msg(2,"**Lamp turned off!!**");  
           Validate h2o2resetA; } 
        Validate h2o2recordA;
}

State h2o2resetA {
        depending on (Shutdown) { Validate h2o2shutOffA; }
        > Command Lamp Module A off
+1      > Set Axis A RF Set Pt 0
+4      Validate h2o2turnOnA;
}

State h2o2shutOffA {
+10     > Command Lamp Module A off
+1      > Set Axis A RF Set Pt 0
}


# -----------------------------------------------------------------------------
# Partition 7: Axis A Lamp Heater On/Off
# -----------------------------------------------------------------------------

Partition

State h2o2heatinitA {
        depending on (h2o2recordA) { Validate h2o2heatOnA; }
}

# TURN ON LAMP HEATER & START SOL CYCLE
# WATCHDOG FOR LAMP RUNNING DEEP
State h2o2heatOnA {
        depending on (Shutdown) { Validate h2o2heatOffA; }
        depending on (h2o2shutOffA) { Validate h2o2heatOffA; }
        depending on (h2o2resetA) { Validate h2o2heatOffA; }
+1      > Set Axis A RF Set Pt 5
+8      > Set Axis A Heat Set Pt 1.5
+1      > Soldrv A select mode 3
        Hold until (convert(BVisV) > 3.0);
        { msg(2,"**Too much heat on A - running deep!**"); }
        > Set Axis A Heat Set Pt 0
		Hold until (convert(AVisV) < 1.0);   	%% AVisV < ???
        > Set Axis A Heat Set Pt 1.5
        Validate h2o2heatOnA;       
}

State h2o2heatOffA {
        depending on (h2o2recordA) { Validate h2o2heatOnA; }
        > Set Axis A Heat Set Pt 0
}




# ------------------------------------------------------------------------------
# Partition 10: Other Watchdogs
# ------------------------------------------------------------------------------

Partition

State Watch_Idle {
 +3     Validate Watch_Run;
}

State Watch_Run {
        {  if ( DISKst > 97) {
                msg(2,"** Running Out of Disk Space **");
                Validate Watch_Failure;
           }
        }
}

State Watch_Failure {
        Validate Shutdown;
}



%{
  #include "hsatod.h"
  #include "swstat.h"
  int qcli_auto_on = 1;
  int two_bits(unsigned char LS ) {
    int nbits = 0;
    if ( LS & LS_1_FAILURE ) ++nbits;
    if ( LS & LS_2_FAILURE ) ++nbits;
    if ( LS & LS_3_FAILURE ) ++nbits;
    return nbits >= 2;
  }
%}



#----------------------------------------------------------------------
# Partition 1: Mainline
#----------------------------------------------------------------------
State Initialize {
     > Telemetry Start

     Hold until Valid (OFF_GROUND);
     Validate Operate;
}

State Operate {
    Depending on (ON_GROUND) { Validate Shutdown; }
    Hold until (two_bits(Laser_Status & LS_FAILURE));
    Validate Laser_Failure;
}

State Laser_Failure {
    { nl_error( 2, "Two or More Lasers have Failed" ); }
     Hold until ((Laser_Status & LS_SHUTDOWN) == LS_SHUTDOWN) or 10;
     Validate Shutdown;
}

State Shutdown {
     Hold until ((Laser_Status & LS_SHUTDOWN) == LS_SHUTDOWN) or 30;
  +4 > Fail Light On
  +1 > Quit
}

Partition
#----------------------------------------------------------------
# Partition 3: HHH
#----------------------------------------------------------------
State HHH_Init {
     Depending on (Shutdown) { Validate HHH_Shutdown; }
     Depending on (Laser_Failure ) { Validate HHH_Shutdown; }
     Depending on (OFF_GROUND) { Validate HHH_Startup; }
     Depending on (IN_AIR) { Validate HHH_Startup; }
}

State HHH_Startup {
     Depending on (Shutdown) { Validate HHH_Shutdown; }
     Depending on (Laser_Failure ) { Validate HHH_Shutdown; }
     Depending on (ON_GROUND) { Validate HHH_Shutdown; }
     Validate DFB_HHH;
}

State HHH_Shutdown {
     
}

Partition
#----------------------------------------------------------------
# Partition 4: Laser1 HHH 1.4um DFB
#----------------------------------------------------------------

%{
 int num_DFB_recovers=0;
 #define LOW_CURRENT 0.02
 #define DFB_TEMP_LIMIT 2.3
 #define DFB_TEMP_OK(x) (x < DFB_TEMP_LIMIT)
%}
# DFB1 Starting and Stopping

State DFB_Init {
  +1 > SSP1 Stop
  +1 > QCLI1 Stop
     Validate DFB_Idle;
}

State DFB_Idle {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
}

State DFB_Start {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    Hold until ( SSP1_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP1 Not Ready in DFB_Start" );
      Validate DFB_SSP_Recover;
    }
    Hold until ( DFB_TEMP_OK(convert(LTE1R4T)) );
    Hold until ( (QCLI1_s & 0x2938) == 0 ) or 5
    else Validate DFB_QCLI_Recover;
 +1 > SSP1 Start
    Hold until ( SSP1_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in DFB_Start" );
      Validate DFB_SSP_Recover;
    }
    > QCLI1 Run
    # Hold until ( SSP1_Status == SSP_STATUS_TRIG && convert(HDFB_I) > LOW_CURRENT ) or 20
    Hold until ( SSP1_Status == SSP_STATUS_TRIG ) or 20
    else Validate DFB_SSP_Recover;
    { num_DFB_recovers = 0; }
    Validate DFB_Watch;
}

{ unsigned long Last_SSP1; }

State DFB_Watch NoLog {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    { if ( SSP1_Status == SSP_STATUS_READY ) {
      nl_error( 2, "SSP1 Went Ready Spontaneously" );
      Validate DFB_SSP_Recover;
      }
    }
         # convert(HDFB_I) < LOW_CURRENT ||
    hold until ( SSP1_Status != SSP_STATUS_TRIG ||
         !DFB_TEMP_OK(convert(LTE1R4T)) );
    # hold until ( DFB_TEMP_OK(convert(LTE1R4T)) && 
    #     convert(HDFB_I) >= LOW_CURRENT) or 1
    hold until ( DFB_TEMP_OK(convert(LTE1R4T)) ) or 1
    else Validate DFB_Out_Spec;
    hold until ( SSP1_Status == SSP_STATUS_TRIG ) or 5
    else Validate DFB_SSP_Recover;
    Validate DFB_Watch;
}

State DFB_SSP_Recover NoLog {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP1 Stop
    { if ( ++num_DFB_recovers > 20 ) {
        nl_error( 2, "Exceeded num_DFB_recovers. Trying reset" );
        num_DFB_recovers = 0;
        Validate DFB_QCLI_Reset;
      }
    }
    Hold until ( SSP1_Status == SSP_STATUS_READY ) or 10
    else Validate DFB_SSP_Not_Talking;
 +2 > QCLI1 Stop
    Validate DFB_Start;
}

State DFB_SSP_Not_Talking {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP1 Stop
    { if ( ++num_DFB_recovers > 20 ) Validate DFB_Fail; }
    Hold until ( SSP1_Status == SSP_STATUS_READY ) or 10
    else Validate DFB_SSP_Not_Talking;
    Validate DFB_SSP_Recover;
}

State DFB_Fail {
    > Laser System 1 Has Failed
 +1 Validate DFB_Shutdown;
}

State DFB_Shutdown {
    > SSP1 Stop
 +1 > QCLI1 Stop
    > Laser System 1 Has Shutdown
}

State DFB_Out_Spec {
   > QCLI1 Stop
 +1 Validate DFB_QCLI_Recover;
}

State DFB_QCLI_Recover {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
   { nl_error( 2, "QCLI1 reporting error status 0x%04X", QCLI1_s ); }
   > QCLI1 Clear Errors
   Hold until ( (QCLI1_s & 0x2938) == 0 ) or 5
   else {
     nl_error( 2, "QCLI1 error did not clear: 0x%04X: Resetting", QCLI1_s );
     Validate DFB_QCLI_Reset;
   }
   Validate DFB_Start;
}

State DFB_QCLI_Reset {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    { if ( ++num_DFB_recovers > 20 ) {
        nl_error( 2,"Exceeded num_DFB_recovers in QCLI_Reset: Invoking shutdown" );
        Validate DFB_Fail;
      }
    }
 +1 > DFB QCLI Reset On
    > DFB QCLI Reset Off
    Hold until ( (QCLI1_s & 0x2938) == 0 ) or 2
    else > QCLI1 clear errors
    Hold until ( (QCLI1_s & 0x2938) == 0 ) or 2
    else Validate DFB_QCLI_Reset;
    { ci_sendfcmd( 0, "Select QCLI1 Waveform Number %d\n", QCLI1_Wave ); }
 +1 Validate DFB_Start;
}

State DFB_Stop {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP1 Stop
 +1 > QCLI1 Stop
    Hold until ( SSP1_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in DFB_Stop" ); }
    Validate DFB_Idle;
}

#Running Waveforms

State DFB_HHH {
    Depending on (HHH_Shutdown) { Validate DFB_Shutdown; }
    > SSP1 Stop
    Hold until ( SSP1_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in DFB_HHH" ); }
    > QCLI1 Stop
 +2 > Select QCLI1 Waveform HHH
 +2 Validate DFB_Start;
}

Partition
#----------------------------------------------------------------
# Partition 7: Software Status
#----------------------------------------------------------------

%{
  /* bits/torr gain: */
  double BV_Gp = 5.;
  double BV_Gi = 1.;
%}

State SW_Stat_Wait NoLog {
  { int reset_it;
    reset_it = 1;
    switch (SWStat) {
      default:
      case 0:   reset_it = 0; break;
      case SWS_TAKEOFF: depending on (ON_GROUND) using_swp = 1; break;
      case SWS_CLIMB: depending on (OFF_GROUND) using_swp = SWStat; break;
      case SWS_DESCEND: depending on (IN_AIR) using_swp = SWStat; break; 
      case SWS_LAND: depending on (OFF_GROUND) using_swp = SWStat; break;

      case SWS_DFB_START: Validate DFB_Start; break;
      case SWS_DFB_STOP: Validate DFB_Stop; break;
      case SWS_DFB_HHH: Validate DFB_HHH; break;

      case SWS_TIME_WARP: break;
      case SWS_READFILE: Validate ReadFile; break;
      case SWS_SHUTDOWN: Validate Shutdown; break;
    }
    if (reset_it) Validate SW_Stat_Reset;
  }
}

State SW_Stat_Reset NoLog {
	> _SW Status Set 0
	Hold until (SWStat == 0) or 10;
	Validate SW_Stat_Wait;
}

Partition
# -----------------------------------------------------------------------------
# Partition 9: Altitude
# -----------------------------------------------------------------------------
# This partition converts pressure (altitude) into states (ON_GROUND,
# OFF_GROUND, IN_AIR). The threshold pressures each have two
# values - one for the flight up and the other for the flight down.
# This provides hysteresis and prevents bouncing.  

# Nominal Altitude values - TO BE CHANGED
%{ /* Altitude definitions */
  double P_ground_up = 610.;
  double P_ground_dn = 630.;
  double P_air_up = 250.;
  double P_air_dn = 350.;
  int using_swp = 0;
%}

State ON_GROUND {
  { using_swp = 0; }
  { if (using_swp || (convert(Amb_P) < P_ground_up))
		  Validate OFF_GROUND;
  }
}

State OFF_GROUND {
  { if ((using_swp == 2) || (!using_swp && convert(Amb_P) < P_air_up)) {
		  Validate IN_AIR;
	} else if ((using_swp == 4) || (!using_swp && convert(Amb_P) > P_ground_dn)) {
		  Validate ON_GROUND;
	}
  }
}

State IN_AIR {
  { if ( (using_swp == 3) || (!using_swp && convert(Amb_P) > P_air_dn))
		  Validate OFF_GROUND;
  }
}

Partition
#-----------------------------------------------------------------------------
# Partition 9: Realtime File Input
#-----------------------------------------------------------------------------
State ReadFile_idle {}

State ReadFile "HHH.tmas" {
 +5 Validate ReadFile_idle;
}

Partition
#---------------------------------------------------------------
# Partition 10: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------

State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SWStat == SWS_TIME_WARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}

